import os


configfile: "config/config.yaml"


CTGS = {c["name"]: c["region"] for c in config["misasim"]["ctgs"]}
ORTS = {
    "fwd",
    # "rev"
}
OUTPUT_DIR = config["misasim"]["output_dir"]
MISASSEMBLIES = config["misasim"]["misassemblies"]
SAMPLES = [c["name"] for c in config["nucflag"]["samples"]]
# TODO: Make so other samples can be added.
MISASM_SAMPLES = [
    f"{ctg}_{misassembly}"
    for ctg, region_bed in CTGS.items()
    for misassembly in MISASSEMBLIES.keys()
    if misassembly != "break"
]
MISASM_SAMPLE_PAIRS = [
    (sm_1, sm_2, ort_1, ort_2)
    for sm_1 in MISASM_SAMPLES
    for sm_2 in MISASM_SAMPLES
    for ort_1 in ORTS
    for ort_2 in ORTS
    if sm_1 != sm_2
]

wildcard_constraints:
    ctg="|".join(CTGS.keys()),
    misassembly="|".join(MISASSEMBLIES.keys()),
    sm="|".join(MISASM_SAMPLES),
    ort="|".join(ORTS),
    sm_1="|".join(MISASM_SAMPLES),
    sm_2="|".join(MISASM_SAMPLES),
    ort_1="|".join(ORTS),
    ort_2="|".join(ORTS),


NUCFLAG_BASE_CFG = {
    **{k: v for k, v in config["nucflag"].items() if k != "samples"},
    "samples": [
        {
            **sm_cfg,
            "config": config["nucflag"]["config_nucflag"],
        }
        for sm_cfg in config["nucflag"]["samples"]
    ]
}

module NucFlag:
    snakefile:
        github(
            "logsdon-lab/Snakemake-NucFlag", path="workflow/Snakefile", branch="dev/mm2"
        )
    config:
        NUCFLAG_BASE_CFG


use rule * from NucFlag as main_*


rule index_asm:
    input:
        asm=config["misasim"]["asm_fa"],
    output:
        asm_faidx=f"{config['misasim']['asm_fa']}.fai",
    conda:
        "env/tools.yaml"
    resources:
        mem=4,
    log:
        "logs/index_asm.log",
    shell:
        """
        samtools faidx {input.asm} 2> {log}
        """


rule extract_contig_from_asm:
    input:
        asm=config["misasim"]["asm_fa"],
        asm_faidx=rules.index_asm.output,
    output:
        ctg_fa=os.path.join(OUTPUT_DIR, "{ctg}.fa"),
    conda:
        "env/tools.yaml"
    resources:
        mem=4,
    log:
        "logs/extract_{ctg}_from_asm.log",
    shell:
        """
        seqtk subseq {input.asm} <(echo "{wildcards.ctg}") > {output} 2> {log}
        """


rule generate_misassembled_contig:
    input:
        misasim_bin="/project/logsdon_shared/projects/misasim/target/release/misasim",
        ctg_fa=rules.extract_contig_from_asm.output.ctg_fa,
        ctg_regions=lambda wc: CTGS[str(wc.ctg)],
    output:
        misasm_fa=os.path.join(OUTPUT_DIR, "{ctg}_{misassembly}.fa"),
        misasm_bed=os.path.join(OUTPUT_DIR, "{ctg}_{misassembly}.bed"),
    log:
        "logs/misasim_{ctg}_{misassembly}.log",
    benchmark:
        "benchmarks/misasim_{ctg}_{misassembly}.tsv"
    resources:
        mem=4,
    params:
        long_params=lambda wc: " ".join(
            f"--{opt} {val}" for opt, val in MISASSEMBLIES[str(wc.misassembly)].items()
        ),
    shell:
        """
        {input.misasim_bin} {wildcards.misassembly} \
        {params.long_params} \
        -i {input.ctg_fa} \
        -r {input.ctg_regions} \
        -b {output.misasm_bed} > {output.misasm_fa} 2> {log}
        """


rule add_misassembled_ctg_to_asm:
    input:
        asm=config["misasim"]["asm_fa"],
        asm_faidx=rules.index_asm.output,
        misassembled_ctg=rules.generate_misassembled_contig.output.misasm_fa,
    output:
        new_asm=os.path.join(OUTPUT_DIR, "{ctg}_{misassembly}_asm.fa"),
    conda:
        "env/tools.yaml"
    resources:
        mem=4,
    log:
        "logs/add_{misassembly}_{ctg}_to_asm.log",
    shell:
        """
        cat <(seqtk subseq {input.asm} <(grep -v "{wildcards.ctg}" {input.asm_faidx} | cut -f 1)) {input.misassembled_ctg} > {output} 2> {log}
        samtools faidx {output}
        """


# Don't run nucflag on breaks. No bases modified just fasta split.
NUCFLAG_MISASIM_CFG = {
    **{k: v for k, v in config["nucflag"].items() if k != "samples"},
    "samples": [
        {
            "name": f"{ctg}_{misassembly}",
            "asm_fa": expand(
                rules.add_misassembled_ctg_to_asm.output,
                ctg=ctg,
                misassembly=misassembly,
            ),
            "read_dir": "data/reads",
            "read_ext": "fastq",
            "region_bed": region_bed,
            "config": config["nucflag"]["config_nucflag"],
        }
        for ctg, region_bed in CTGS.items()
        for misassembly in MISASSEMBLIES.keys()
        if misassembly != "break"
    ],
}


module NucFlagMisasim:
    snakefile:
        github(
            "logsdon-lab/Snakemake-NucFlag", path="workflow/Snakefile", branch="dev/mm2"
        )
    config:
        NUCFLAG_MISASIM_CFG


use rule * from NucFlagMisasim as misasim_*


# Run minimap on pair of contigs
rule align_pairs:
    input:
        ref_fa=os.path.join(OUTPUT_DIR, "{sm_1}.fa"),
        query_fa=os.path.join(OUTPUT_DIR, "{sm_2}.fa"),
        region_bed="data/region.bed",
    output:
        paf=os.path.join(OUTPUT_DIR, "repair", "{sm_1}_{ort_1}_{sm_2}_{ort_2}.paf"),
    params:
        aln_preset="asm5",
        reverse_ref=lambda wc: "| seqtk seq -r" if wc.ort_1 == "rev" else "",
        reverse_query=lambda wc: "| seqtk seq -r" if wc.ort_2 == "rev" else "",
    conda:
        "env/tools.yaml"
    resources:
        mem=50,
    threads: 8
    log:
        "logs/align_pairs_{sm_1}_{ort_1}_{sm_2}_{ort_2}.log",
    shell:
        """
        minimap2 -t {threads} -c --eqx \
        -x {params.aln_preset} \
        <(seqtk subseq {input.ref_fa} {input.region_bed} {params.reverse_ref}) \
        <(seqtk subseq {input.query_fa} {input.region_bed} {params.reverse_query}) > {output.paf} 2> {log}
        """


rule filter_format_paf:
    input:
        paf=rules.align_pairs.output.paf,
    output:
        paf=os.path.join(OUTPUT_DIR, "repair", "{sm_1}_{ort_1}_{sm_2}_{ort_2}_format.paf"),
    params:
        max_size=1,
    resources:
        mem=20,
    log:
        "logs/align_pairs_{sm_1}_{ort_1}_{sm_2}_{ort_2}_format.log",
    shell:
        """
        {{ paste -d"\\t" \
            <(cut -f 1-17 {input.paf}) \
            <(grep -Po "cg:Z:(.+)" {input.paf}) | \
           awk '$17 == "tp:A:P"' \
        ;}} > {output.paf} 2> {log}
        """


rule reorient_misassemblies:
    input:
        misasm_bed=lambda wc: expand(rules.misasim_check_asm_nucflag.output.misassemblies, sm=wc.sm),
    output:
        reort_misasm_bed=os.path.join(OUTPUT_DIR, "concensus", "{sm}_{ort}.bed"),
    resources:
        mem=4
    run:
        with (
            open(str(input)) as in_fh,
            open(str(output), "wt") as out_fh,
        ):
            for line in in_fh.readlines():
                if wildcards.ort == "fwd":
                    out_fh.write(line)
                    continue
                name, start, stop, status = line.strip().split()
                _, coord = name.split(":")
                ctg_start, ctg_stop = coord.split("-")
                start, stop, ctg_start, ctg_stop = int(start), int(stop), int(ctg_start), int(ctg_stop)
                new_start = (ctg_stop - stop) + ctg_start
                new_stop = (ctg_stop - start) + ctg_start
                out_fh.write(f"{name}\t{new_start}\t{new_stop}\t{status}\n")


rule generate_concensus:
    input:
        script="workflow/scripts/concensus.py",
        paf=rules.filter_format_paf.output,
        ref_fa=os.path.join(OUTPUT_DIR, "{sm_1}.fa"),
        query_fa=os.path.join(OUTPUT_DIR, "{sm_2}.fa"),
        misasm_ref_bed=lambda wc: expand(rules.reorient_misassemblies.output, sm=wc.sm_1, ort=wc.ort_1),
        misasm_query_bed=lambda wc: expand(rules.reorient_misassemblies.output, sm=wc.sm_2, ort=wc.ort_2),
    output:
        fa=os.path.join(OUTPUT_DIR, "concensus", "{sm_1}_{ort_1}_{sm_2}_{ort_2}.fa"),
        bed=os.path.join(OUTPUT_DIR, "concensus", "{sm_1}_{ort_1}_{sm_2}_{ort_2}.bed"),
    conda:
        "env/py.yaml"
    params:
        merge="--merge"
    resources:
        mem=4,
    log:
        "logs/generate_concensus_{sm_1}_{ort_1}_{sm_2}_{ort_2}.log",
    shell:
        """
        python {input.script} \
        -i {input.paf} -r {input.ref_fa} -q {input.query_fa} \
        -b {output.bed} -o {output.fa} \
        --input_ref_misasm_bed {input.misasm_ref_bed} \
        --input_query_misasm_bed {input.misasm_query_bed} \
        {params.merge} 2> {log}
        """

rule add_corrected_ctg_to_asm:
    input:
        asm=config["misasim"]["asm_fa"],
        asm_faidx=rules.index_asm.output,
        corrected_ctg=rules.generate_concensus.output.fa,
    output:
        new_asm=os.path.join(OUTPUT_DIR, "corrected", "{ctg}_{sm_1}_{ort_1}_{sm_2}_{ort_2}_asm.fa"),
    conda:
        "env/tools.yaml"
    resources:
        mem=10,
    log:
        "logs/add_{sm_1}_{ort_1}_{sm_2}_{ort_2}_{ctg}_to_asm.log",
    shell:
        """
        {{ cat <(seqtk subseq {input.asm} <(grep -v "{wildcards.ctg}" {input.asm_faidx} | cut -f 1)) {input.corrected_ctg} | seqkit rmdup ;}} > {output} 2> {log}
        samtools faidx {output} 2>> {log}
        """


# Don't run nucflag on breaks. No bases modified just fasta split.
NUCFLAG_CORRECT_CFG = {
    **{k: v for k, v in config["nucflag"].items() if k != "samples" or k != "output_dir"},
    "output_dir": "results/nucflag_correct",
    "samples": [
        {
            "name": f"{ctg}_{sm_1}_{ort_1}_{sm_2}_{ort_2}",
            "asm_fa": os.path.join(OUTPUT_DIR, "corrected", f"{ctg}_{sm_1}_{ort_1}_{sm_2}_{ort_2}_asm.fa"),
            "read_dir": "data/reads",
            "read_ext": "fastq",
            "region_bed": region_bed,
            "config": config["nucflag"]["config_nucflag"],
        }
        for ctg, region_bed in CTGS.items()
        for sm_1, sm_2, ort_1, ort_2 in MISASM_SAMPLE_PAIRS
    ],
}


module NucFlagCorrect:
    snakefile:
        github(
            "logsdon-lab/Snakemake-NucFlag", path="workflow/Snakefile", branch="dev/mm2"
        )
    config:
        NUCFLAG_CORRECT_CFG


use rule * from NucFlagCorrect as correct_*


rule all:
    input:
        expand(
            rules.main_nucflag.input,
            sm=SAMPLES,
        ),
        expand(
            rules.generate_misassembled_contig.output,
            ctg=CTGS.keys(),
            misassembly=MISASSEMBLIES.keys(),
        ),
        expand(
            rules.add_misassembled_ctg_to_asm.output,
            ctg=CTGS.keys(),
            misassembly=MISASSEMBLIES.keys(),
        ),
        expand(
            rules.misasim_nucflag.input,
            sm=MISASM_SAMPLES,
        ),
        [
            [
                os.path.join(OUTPUT_DIR, "repair", f"{sm_1}_{ort_1}_{sm_2}_{ort_2}.paf"),
                os.path.join(OUTPUT_DIR, "concensus", f"{sm_1}_{ort_1}_{sm_2}_{ort_2}.fa"),
                os.path.join(OUTPUT_DIR, "concensus", f"{sm_1}_{ort_1}_{sm_2}_{ort_2}.bed"),
            ]
            for sm_1, sm_2, ort_1, ort_2 in MISASM_SAMPLE_PAIRS
        ],
        expand(
            rules.correct_nucflag.input,
            sm=MISASM_SAMPLES,
        ),
    default_target: True
