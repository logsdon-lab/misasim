import os


configfile: "config/config.yaml"


CTGS = {c["name"]: c["region"] for c in config["misasim"]["ctgs"]}
ORTS = {"fwd", "rev"}
OUTPUT_DIR = config["misasim"]["output_dir"]
MISASSEMBLIES = config["misasim"]["misassemblies"]
SAMPLES = [c["name"] for c in config["nucflag"]["samples"]]
# TODO: Make so other samples can be added.
MISASM_SAMPLES = [
    f"{ctg}_{misassembly}"
    for ctg, region_bed in CTGS.items()
    for misassembly in MISASSEMBLIES.keys()
    if misassembly != "break"
]


wildcard_constraints:
    ctg="|".join(CTGS.keys()),
    misassembly="|".join(MISASSEMBLIES.keys()),
    sm="|".join(MISASM_SAMPLES),
    sm_1="|".join(MISASM_SAMPLES),
    sm_2="|".join(MISASM_SAMPLES),
    ort_1="|".join(ORTS),
    ort_2="|".join(ORTS),


module NucFlag:
    snakefile:
        github(
            "logsdon-lab/Snakemake-NucFlag", path="workflow/Snakefile", branch="main"
        )
    config:
        config["nucflag"]


use rule * from NucFlag as main_*


rule index_asm:
    input:
        asm=config["misasim"]["asm_fa"],
    output:
        asm_faidx=f"{config['misasim']['asm_fa']}.fai",
    conda:
        "env/tools.yaml"
    resources:
        mem=4,
    log:
        "logs/index_asm.log",
    shell:
        """
        samtools faidx {input.asm} 2> {log}
        """


rule extract_contig_from_asm:
    input:
        asm=config["misasim"]["asm_fa"],
        asm_faidx=rules.index_asm.output,
    output:
        ctg_fa=os.path.join(OUTPUT_DIR, "{ctg}.fa"),
    conda:
        "env/tools.yaml"
    resources:
        mem=4,
    log:
        "logs/extract_{ctg}_from_asm.log",
    shell:
        """
        seqtk subseq {input.asm} <(echo "{wildcards.ctg}") > {output} 2> {log}
        """


rule generate_misassembled_contig:
    input:
        misasim_bin="/home/koisland/misasim/target/release/misasim",
        ctg_fa=rules.extract_contig_from_asm.output.ctg_fa,
        ctg_regions=lambda wc: CTGS[str(wc.ctg)],
    output:
        misasm_fa=os.path.join(OUTPUT_DIR, "{ctg}_{misassembly}.fa"),
        misasm_bed=os.path.join(OUTPUT_DIR, "{ctg}_{misassembly}.bed"),
    log:
        "logs/misasim_{ctg}_{misassembly}.log",
    benchmark:
        "benchmarks/misasim_{ctg}_{misassembly}.tsv"
    resources:
        mem=4,
    params:
        long_params=lambda wc: " ".join(
            f"--{opt} {val}" for opt, val in MISASSEMBLIES[str(wc.misassembly)].items()
        ),
    shell:
        """
        {input.misasim_bin} {wildcards.misassembly} \
        {params.long_params} \
        -i {input.ctg_fa} \
        -r {input.ctg_regions} \
        -b {output.misasm_bed} > {output.misasm_fa} 2> {log}
        """


rule add_misassembled_ctg_to_asm:
    input:
        asm=config["misasim"]["asm_fa"],
        asm_faidx=rules.index_asm.output,
        misassembled_ctg=rules.generate_misassembled_contig.output.misasm_fa,
    output:
        new_asm=os.path.join(OUTPUT_DIR, "{ctg}_{misassembly}_asm.fa"),
    conda:
        "env/tools.yaml"
    resources:
        mem=4,
    log:
        "logs/add_{misassembly}_{ctg}_to_asm.log",
    shell:
        """
        cat <(seqtk subseq {input.asm} <(grep -v "{wildcards.ctg}" {input.asm_faidx} | cut -f 1)) {input.misassembled_ctg} > {output} 2> {log}
        samtools faidx {output}
        """


# Don't run nucflag on breaks. No bases modified just fasta split.
NUCFLAG_MISASIM_CFG = {
    **{k: v for k, v in config["nucflag"].items() if k != "samples"},
    "samples": [
        {
            "name": f"{ctg}_{misassembly}",
            "asm_fa": expand(
                rules.add_misassembled_ctg_to_asm.output,
                ctg=ctg,
                misassembly=misassembly,
            ),
            "read_dir": "data/reads",
            "read_ext": "fastq",
            "region_bed": region_bed,
        }
        for ctg, region_bed in CTGS.items()
        for misassembly in MISASSEMBLIES.keys()
        if misassembly != "break"
    ],
}


module NucFlagMisasim:
    snakefile:
        github(
            "logsdon-lab/Snakemake-NucFlag", path="workflow/Snakefile", branch="main"
        )
    config:
        NUCFLAG_MISASIM_CFG


use rule * from NucFlagMisasim as misasim_*


# Run minimap on pair of contigs
rule align_pairs:
    input:
        ref_fa=os.path.join(OUTPUT_DIR, "{sm_1}.fa"),
        query_fa=os.path.join(OUTPUT_DIR, "{sm_2}.fa"),
        region_bed="data/region.bed",
    output:
        paf=os.path.join(OUTPUT_DIR, "repair", "{sm_1}_{ort_1}_{sm_2}_{ort_2}.paf"),
    params:
        aln_preset="asm5",
        reverse_ref=lambda wc: "| seqtk seq -r" if wc.ort_1 == "rev" else "",
        reverse_query=lambda wc: "| seqtk seq -r" if wc.ort_2 == "rev" else "",
    conda:
        "env/tools.yaml"
    resources:
        mem=50,
    threads: 8
    log:
        "logs/align_pairs_{sm_1}_{ort_1}_{sm_2}_{ort_2}.log",
    shell:
        """
        minimap2 -t {threads} -c --eqx \
        -x {params.aln_preset} \
        <(seqtk subseq {input.ref_fa} {input.region_bed} {params.reverse_ref}) \
        <(seqtk subseq {input.query_fa} {input.region_bed} {params.reverse_query}) > {output.paf} 2> {log}
        """


rule filter_break_paf:
    input:
        paf=rules.align_pairs.output.paf,
    output:
        paf=os.path.join(OUTPUT_DIR, "repair", "{sm_1}_{ort_1}_{sm_2}_{ort_2}_break.paf"),
    conda:
        "env/tools.yaml"
    params:
        max_size=1,
    resources:
        mem=20,
    log:
        "logs/align_pairs_{sm_1}_{ort_1}_{sm_2}_{ort_2}_break.log",
    shell:
        """
        {{ awk '$17 == "tp:A:P"' {input.paf} | rb break-paf --max-size {params.max_size};}} > {output.paf} 2> {log}
        """


# rule generate_concensus:
#     input:
#         rules.align_pairs.output
#     output:
#     params:
#     conda:
#         "env/tools.yaml"
#     log:
#         "logs/generate_concensus_{sm_1}_{sm_2}_{ctg}.log",
#     shell:
#         """
#         python
#         """

rule all:
    input:
        expand(
            rules.main_nucflag.input,
            sm=SAMPLES,
        ),
        expand(
            rules.generate_misassembled_contig.output,
            ctg=CTGS.keys(),
            misassembly=MISASSEMBLIES.keys(),
        ),
        expand(
            rules.add_misassembled_ctg_to_asm.output,
            ctg=CTGS.keys(),
            misassembly=MISASSEMBLIES.keys(),
        ),
        expand(
            rules.misasim_nucflag.input,
            sm=MISASM_SAMPLES,
        ),
        [
            os.path.join(OUTPUT_DIR, "repair", f"{sm_1}_{ort_1}_{sm_2}_{ort_2}_break.paf")
            for sm_1 in MISASM_SAMPLES
            for sm_2 in MISASM_SAMPLES
            for ort_1 in ORTS
            for ort_2 in ORTS
            if sm_1 != sm_2
        ],
    default_target: True
